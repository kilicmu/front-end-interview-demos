
## 基本特性

1. **并发**：同意时间内多个程序执行（并发：同时刻多个事件，并行：同时间断多个事件）
2. **共享**：系统中资源可以被内存中多个并发执行的线程共同使用
3. **虚拟**：通过分时复用，分空复用，实现将实体虚拟为多个
4. **异步**：系统中的进程以走走停停执行，速度不可知

## 主要功能：

* **处理机管理**：进程管理（进程控制，进程同步，进程通信和进程调度）
* **存储器管理**：内存分配、内存保护、地址映射、内存扩充
* **设备管理**：对IO设备的管理，同时完成IO请求
* **文件管理**：管理用户文件和系统文件。包括磁盘存储空间管理，目录管理，文件共享与保护等

## 系统的调用

一般指**用户态与内核态的转换**

## 宏内核和微内核

* 宏内核：

  将操作系统功能**全部集成在内核**中，由于内核中模块的高内聚，共享信息的性能很高

* 微内核：

  **将一部分系统功能移除内核**，用于降低内核复杂度。移除部分由分层原则会划分为若干个服务。这些服务之间遵循相互独立的原则

  缺陷：需要频繁的进行系统调用

## 中断

* 外中断：

  **由CPU指令以外事件引起的中断**，如I/O中断，表示输入输出事件已经完成，处理器能发送下一个输入输出请求。还有**输出中断**和**控制台中断**等

* 异常：

  由CPU指令引发的事件，如非法操作码，地址越界，算数溢出。

* 陷入：

  用户程序使用系统调用。

## 进程与线程

### 进程：

* 定义：进程是进程实体的运行过程，是**系统进行资源分配和调度的一个独立单位**

  进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。

* 目的：为了使多个程序可以**并发的执行**，以提高系统的资源利用率和吞吐量。

* 进程的状态：

  ![img](https://camo.githubusercontent.com/99816e8c9d2d59b711ec4134f6200857074596e4/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f50726f6365737353746174652e706e67)

  - 就绪状态（ready）：进程**获得了除了CPU之外的所有的必要资源**，只要获得CPU就可以立即执行，此时的进程处于就绪态
  - 运行状态（running）：进程已经**获得CPU**，正在运行，在多处理其系统中，会有多个进程同时处于运行状态
  - 阻塞状态（waiting）：处于执行状态的进程由于发生某些事件而暂时无法继续执行，**放弃处理机**而处于暂停状态，此时进程就处于阻塞（执行受到阻塞）状态

* 进程状态的转换：

  * 就绪->执行：调度进程为其分配了处理机
  * 执行->就绪：时间片用完
  * 执行->阻塞：申请临界资源而未被满足，如IO请求或者申请缓存
  * 阻塞->就绪：请求得到满足，如IO完成

### 线程：

定义：是比进程更小的**可独立运行的基本单位**

目的：为了**减少程序在并发执行过程中的开销**，使OS的并发效率更高。

### 对比：

|      | 进程              | 线程                   |
| ---- | ----------------- | ---------------------- |
| 调度 | 保存和恢复CPU环境 | 保存和恢复少量的寄存器 |
| 并发 | 可以并发          | 可以并发               |
| 资源 | 拥有资源          | 没有资源               |
| 开销 | 大                | 小                     |

## 进程调度算法

不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。

### 基本调度算法：

##### **先来先服务 first-come first-serverd（FCFS）**

非抢占式的调度算法，按照请求的顺序进行调度。

有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

##### **短作业优先 shortest job first（SJF）**

非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

##### **最短剩余时间优先 shortest remaining time next（SRTN）**

最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

##### **时间片轮转**

将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

时间片轮转算法的效率和时间片的大小有很大关系：

- 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
- 而如果时间片过长，那么实时性就不能得到保证。

[![img](https://camo.githubusercontent.com/8ff909218be7e1269ee5912f0aba9fcb3552df3b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38633636323939392d633136632d343831632d396634302d3166646261356263393136372e706e67)](https://camo.githubusercontent.com/8ff909218be7e1269ee5912f0aba9fcb3552df3b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38633636323939392d633136632d343831632d396634302d3166646261356263393136372e706e67)



##### **优先级调度**

为每个进程分配一个优先级，按优先级进行调度。

为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

##### **多级反馈队列**

一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。

多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。

每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

[![img](https://camo.githubusercontent.com/a69a61aafa8f82822c3679b989d58d1ce332f9ae/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30343263663932382d336338652d343831352d616539632d6632373830323032633638662e706e67)](https://camo.githubusercontent.com/a69a61aafa8f82822c3679b989d58d1ce332f9ae/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30343263663932382d336338652d343831352d616539632d6632373830323032633638662e706e67)

### 实时调度算法：

##### 最早截止时间优先调度算法EDF

根据任务的开始截止时间确定优先级，截止时间越早，优先级越高。维护一个实时就绪队列，最早截止时间的任务排在最前面；可以用于抢占式调度也可以用于非抢占式调度；

##### 最低松弛度优先调度算法LLF

松弛度=(必须完成时间-本身运行时间-当前时间)，松弛度代表了任务的紧急程度，任务的紧急程度越高，被赋予的优先级越高

## 进程的通信：

* 管道（半双工，只能用于父子与兄弟进程）
* 具名管道
* 消息队列
* 共享内存
* 信号量
* socket

## 死锁：

死锁是指多个进程在运行过程中，因为争夺资源而造成的一种僵局，如果没有外力推进，处于僵局中的进程就无法继续执行。

### 必要条件：

* 互斥：资源要么已经分配给了一个进程，要么就是可用的。
* 占有和等待：已经获得资源的线程可以再获得新的资源
* 不可抢占：已经分配的资源不可再度被抢占
* 环路等待：有两个或两个以上进程组成一个环路，该环路中每个进程都在等待下一个进程所占有资源

### 死锁处理

1. 鸵鸟策略：忽略死锁

2. 死锁的检测与恢复：

   检测算法：

   ​	通过深度优先遍历搜索，标记所有访问的节点，如果对节点发生了二次访问，则证明出现的环。

   恢复：

   * 抢占
   * 回滚
   * 杀死进程

3. 死锁预防止

   * 破坏互斥：通过虚拟设备技术，允许资源被同时使用
   * 破坏占有和等待：进程在开始执行前获取全部资源
   * 破坏环路等待：对资源统一编号，只能按编号请求资源

4. 死锁避免

   银行家算法

## 内存管理：

### 虚拟内存技术

目的： 物理内存扩充成更大的逻辑内存

操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一**页**。

这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，**将缺失的部分装入物理内存并重新执行失败的指令。**

### 分页系统的地址映射

* 分页管理单元（MUMU）：管理地址空间与物理内存转换
* 页框：物理内存

* 页表（Page Table）：页和叶框的映射表

一个虚拟地址分成两个部分，一部分存储页面号，一部分存储偏移量。

下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位。例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1），页表项最后一位表示是否存在于内存中，1 表示存在。后 12 位存储偏移量。这个页对应的页框的地址为 （110 000000000100）。

![页面映射](https://i.niupic.com/images/2020/10/11/8RqH.png)

### 页面置换算法

在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。

##### OPT（理想算法）

所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。

无法实现

##### LRU（ 最近最久未使用）

LRU 将最近最久未使用的页面换出

实现：需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面是最近最久未访问的。

##### 最近未使用

每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R=1，当页面被修改时设置 M=1。其中 R 位会定时被清零。可以将页面分成以下四类：

- R=0，M=0
- R=0，M=1
- R=1，M=0
- R=1，M=1

当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。

NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。

##### FIFO

选择换出的页面是最先进入的页面。

##### 第二次机会算法

当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。

##### 时钟

第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。



### 分段

分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。

分段内存管理当中，地址是二维的，一维是段号，一维是段内地址；

其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。段表中的每一个表项记录了该段在内存中的起始地址和该段的长度。段表可以放在内存中也可以放在寄存器中。

### 分段和分页对比

1. 页是信息的物理单位，是出于系统内存利用率的角度提出的离散分配机制；段是信息的逻辑单位，每个段含有一组意义完整的信息，是出于用户角度提出的内存管理机制
2. 页的大小是固定的，由系统决定；段的大小是不确定的，由用户决定
3. 页地址空间是一维的，段地址空间是二维的

### 段页式

程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。

## 磁盘

结构：

* 盘面
* 磁道
* 扇区
* 磁头
* 制动手臂
* 主轴

## 磁盘调度算法

* 先来先服务
* 最短寻道优先
* 电梯调度算法